# pylint: disable=too-many-arguments
"""
Photo upload endpoint is defined here.
"""
import io
import os

from fastapi import Depends, File, Form, HTTPException, Response, UploadFile
from fastapi.responses import FileResponse
from loguru import logger
from PIL import Image
from sqlalchemy.ext.asyncio import AsyncConnection
from starlette import status
from facades_api.config.app_settings_global import app_settings

from facades_api.db.connection import get_connection
from facades_api.db.entities.enums import PTEnum
from facades_api.dto import User as UserDTO
from facades_api.logic import classify_defects, save_classification_results, save_photo, update_evaluation_value
from facades_api.logic.evaluation import get_evaluation_value_raw
from facades_api.logic.exceptions import FileSizeError
from facades_api.logic.photos import get_building_photos as get_building_photos_from_db
from facades_api.schemas import UploadPhotoResponse
from facades_api.schemas.photos import PhotosGetResponse
from facades_api.utils import draw_defects
from facades_api.utils.dependencies import user_dependency

from .routers import photos_router


@photos_router.post("/photo/upload", status_code=status.HTTP_200_OK)
async def upload_photo(
    building_id: int = Form(...),
    angle_type: PTEnum = Form(...),
    photo_file: UploadFile = File(...),
    user: UserDTO = Depends(user_dependency),
    conn: AsyncConnection = Depends(get_connection),
) -> UploadPhotoResponse:
    """
    Upload photo to the system and get `photo_id` and `mark_id` generated by the classifier.
    """
    photo = await photo_file.read(20 << 20)
    if not (600 << 10) <= len(photo) < (20 << 20):  # 600kb .. 20mb
        raise FileSizeError(len(photo))
    photo_id, photo_saved = await save_photo(conn, photo, user.id, building_id, angle_type)
    classification_results = await classify_defects(photo_saved)
    mark_id = await save_classification_results(conn, photo_id, classification_results)
    await update_evaluation_value(conn, building_id)
    return UploadPhotoResponse(photo_id=photo_id, classifier_mark_id=mark_id)


@photos_router.post(
    "/photo/classify",
    status_code=status.HTTP_200_OK,
    responses={status.HTTP_200_OK: {"content": {"image/jpg": {}}}},
)
async def classify_photo(angle_type: PTEnum, photo_file: UploadFile = File(...)):
    """
    Pass given photo directly to the classifier service and get an image with marked defects.
    """
    logger.debug("classification request")
    photo = await photo_file.read(20 << 20)
    if not (600 << 10) <= len(photo) < (20 << 20):  # 600kb .. 20mb
        raise FileSizeError(len(photo))
    classification_results = await classify_defects(photo)
    logger.debug("classified {} defects", len(classification_results))
    buf = io.BytesIO(photo)
    image = draw_defects(Image.open(buf), classification_results)
    imgage_byte_arr = io.BytesIO()
    image.save(imgage_byte_arr, format="jpeg")
    evaluation_raw = get_evaluation_value_raw(
        [(angle_type, d.box[0], d.box[1], d.class_name) for d in classification_results]
    )
    return Response(
        content=imgage_byte_arr.getvalue(),
        media_type="image/jpg",
        headers={
            "X-Defects-Count": str(len(classification_results)),
            "X-Evaluation-Value-Raw": str(evaluation_raw),
            "X-Evaluation-Value": str(min(max(evaluation_raw, 0.0), 10.0)),
        },
    )


@photos_router.get(
    "/photo/{photo_id}",
    status_code=status.HTTP_200_OK,
    responses={status.HTTP_200_OK: {"content": {"image/jpg": {}}}},
)
async def get_photo(photo_id: int) -> FileResponse:
    """
    Get photo image by id.
    """
    if not os.path.isfile(image := os.path.join(app_settings.photos_directory, f"{photo_id}.jpg")):
        raise HTTPException(404, f"Photo with id={photo_id} is not found")

    return FileResponse(image)


@photos_router.get("/building/{building_id}/photos", status_code=status.HTTP_200_OK)
async def get_building_photos(building_id: int, conn: AsyncConnection = Depends(get_connection)) -> PhotosGetResponse:
    """
    Get photos list for a given building.
    """
    return PhotosGetResponse.from_dto(await get_building_photos_from_db(conn, building_id))
